
### 前面的待放链接

## 4月5日 字符串枚举优化
> https://ac.nowcoder.com/acm/problem/23053

题目：给定序列s,t,判断t是否是s的子序列  
比如主串是abcdefgh，子串是 aez，那么当 a 匹配上了之后，再去枚举主串中的 bcd 其实是没有意义的，如果我们能做到在 a 之后跳到 a 后面第一个 e 然后在 e 之后跳到后面的第一个 z（如果有的话），直到子串遍历完或者跳不动了，就能出结果了。（**如果主串中有两个一样的字母，我们肯定会选前一个**，因为是**子序列**，如果选前一个不可以，那么选后面的同一个字母肯定就更不可以了，因为选越靠后的字母给后面留下的选择余地就越小。）
思想可以参考KMP利用next数组匹配子串
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int nex[maxn][26];
int last[26]={0};
void pre(string s)
{
    memset(last,-1,sizeof(last));
    int len=s.size();
    for(int i=len-1;i>=0;--i){
        int c=s[i]-'a';
        //cout<<c<<endl;
        memcpy(nex[i],last,sizeof(int)*26);
        last[c]=i;
    }
    return;
}

int main(){
    string s;cin>>s;
    int n;cin>>n;
    pre(s);
    for(int i=0;i<n;++i){
        bool ok=false;
        string t;cin>>t;
        int len=t.size();
        int ne=last[t[0]-'a'];
        for(int i=1;i<len;++i){
            ne=nex[ne][t[i]-'a'];
            //cout<<t[i]<<" "<<ne<<endl;
            if(ne==-1) {
                cout<<"No"<<endl;
                ok=true;
                break;
            }
        }
        if(!ok)cout<<"Yes"<<endl;
    }
}
```
## 4月5日 树上DP/DFS
> https://ac.nowcoder.com/acm/problem/22598

n 个节点 n-1 条边的无向连通图，每条边有一个边权 wi；  
选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为 1 的点都不能到达 S。   
定义删除一条边的代价为这条边的边权,求最小代价。  
看到**n个点n-1条边实际上就是一颗树**；  
在以S为根的树上删掉权值和尽量小的一些边使得根和每一个叶子节点都不连通。

【树是最能体现递归的，递归是从顶向下的，转化成从底向上就变成了DP，所以“树上”的题目真是前变万化~~~既可以叫dp也可以叫dfs】

不管是写dp还是写搜索其实都是要分析原问题和子问题分别是什么的，我们的原问题是以S为根的子树删掉权值和尽量小的一些边使得S和每一个叶子节点都不连通，那么子问题也很简单，就是求以x为根的子树删掉一些边使得S和x的子树上每个叶子节点都不连通。要想在考虑x这个点的子树的时候就实现子树上每个叶子都和S不连通，那么有两种情况：把x和他的儿子断开，或者是，在x的子树上去把所有叶子节点都断开。如果我们用f[x]表示x的子树上的所有叶子和根断开的最小代价的话， $f[x]=\sum min(f[y],w[x][y])$
(y是x的儿子(枚举所有儿子,$w[x][y]$是x到y的边长)。 dfs在返回的时候维护这些值就好。  
即：**子问题**：以x为根的子树上的所有叶子和根断开的最小代价   
dfs转移时候**选择**断开与儿子的边还是断开儿子字树的边即可

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 100000 * 2 +10 ;
ll f[maxn/2];// f[x]表示x的子树上的所有叶子和根断开的最小代价
int p[maxn],h[maxn],ne[maxn],edge[maxn];
int num=0;

void addEdge(int from, int to,int w){ 
    p[++num] = to;//to->from
    ne[num] = h[from];
    h[from] = num;
    edge[num]=w;
    p[++num] = from;
    ne[num] = h[to];
    h[to]=num;
    edge[num]=w;
}
int inD[maxn/2];//入度
int n,m,s;
void dfs(int u,int fa)
{
    if(inD[u] == 1 && u != s){
        f[u] = 0x3f3f3f3f;
        return;
    }
    for(int i = h[u];i;i = ne[i])if(p[i]!=fa)
    {
        int child = p[i],w = edge[i];
        dfs(child,u);
        f[u] += min(1ll*w,f[child]);
    }
}
int main()
{
   // freopen("1.in","r",stdin);
    scanf("%d %d %d",&n,&m,&s);
    for(int i = 1 ;i <= m;i++)
    {
        int u,v,w;
        scanf("%d %d %d",&u,&v,&w);
        addEdge(u,v,w);
        ++inD[u],++inD[v];
    }
    dfs(s,0);
    cout<<f[s];
    return 0;
}
```
## 再来一个树上距离
> https://ac.nowcoder.com/acm/contest/5086/C
> 
求出B 到 C，C到 1的距离和 dis1   
求出A 到 1的距离 dis2  
如果 $dis1<dis2$ 肯定抓不到  
如果 $dis1>dis2$ 肯定抓的到  
如果 $dis1==dis2$时且$LCA(A,C) == 1$ 则他们俩最终会在1相遇,则抓不到，其他情况老师可以去$LCA(A,C)$守株待兔  


## 坑死我了的longlong
就因为一个错误调了一个小时没找出来。。。。。fuck fuck  
https://ac.nowcoder.com/acm/contest/5086/A  
一个数移到左边所减少的量=$nums[i]*k$ 增加的量为$sum(i-k,i)$  
总的减少量$nums[i]*k-sum(i-k,i)$
维护前缀和，枚举下标从k~n-1,找出最少的减少量delta即可
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int n;scanf("%d",&n);
        int k;scanf("%d",&k);
        int nums[maxn];
        ll sum[maxn]={0};
         //错误写法：int sum[maxn]
        unsigned ll ans=0;
        for(int i=1;i<=n;++i){
            scanf("%d",&nums[i-1]);
            ans+=i*nums[i-1];
            sum[i]=sum[i-1]+nums[i-1];
        }
        ll delta = 9223372036854775807;
        //错误写法：ll delta=0x3f3f3f3f
        for(int i=n-1;i>=k;--i){
            ll dd = nums[i]*k-sum[i]+sum[i-k];
            delta=min(delta,dd);
        }
        printf("%lld\n",ans-delta);
    }
}
```

## dfs预处理
定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。
比如说，47、744、4都是幸运数字而5、17、467都不是。
定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + ... + next(r - 1) + next(r)。  
dfs打表预处理出只含有4、7的数字  
然后O(n)顺着往下找即可，比如l=48 找到第一个大于l的数为74 则[48,74]这个区间的数的下一个幸运数都为74。 参看代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5+5;
ll a[N], k = 0;
void dfs(ll n)  //打表
{
    if(n>2e10) return;
    a[k++] = n;
    dfs(n*10+4);
    dfs(n*10+7);
}
 
int main()
{
    dfs(0);
    sort(a,a+k);
    ll l,r;
    scanf("%lld %lld",&l,&r);
    ll sum = 0, i = l, dx = 0;
    while(i<=r)
    {
        while(a[dx]<i) dx++;
        sum += a[dx]*(min(r,a[dx])-i+1);  //在i->第一个大于等于x的数这个区间内，每次加的都是这个第一个>=x的a[dx]
        i = a[dx]+1;  //下一次从a[dx]之后开始
    }
    printf("%lld\n",sum);
    return 0;
}
```