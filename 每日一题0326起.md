
### 前面的待放链接

## 4月5日 字符串枚举优化
> https://ac.nowcoder.com/acm/problem/23053

题目：给定序列s,t,判断t是否是s的子序列  
比如主串是abcdefgh，子串是 aez，那么当 a 匹配上了之后，再去枚举主串中的 bcd 其实是没有意义的，如果我们能做到在 a 之后跳到 a 后面第一个 e 然后在 e 之后跳到后面的第一个 z（如果有的话），直到子串遍历完或者跳不动了，就能出结果了。（**如果主串中有两个一样的字母，我们肯定会选前一个**，因为是**子序列**，如果选前一个不可以，那么选后面的同一个字母肯定就更不可以了，因为选越靠后的字母给后面留下的选择余地就越小。）
思想可以参考KMP利用next数组匹配子串
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int nex[maxn][26];
int last[26]={0};
void pre(string s)
{
    memset(last,-1,sizeof(last));
    int len=s.size();
    for(int i=len-1;i>=0;--i){
        int c=s[i]-'a';
        //cout<<c<<endl;
        memcpy(nex[i],last,sizeof(int)*26);
        last[c]=i;
    }
    return;
}

int main(){
    string s;cin>>s;
    int n;cin>>n;
    pre(s);
    for(int i=0;i<n;++i){
        bool ok=false;
        string t;cin>>t;
        int len=t.size();
        int ne=last[t[0]-'a'];
        for(int i=1;i<len;++i){
            ne=nex[ne][t[i]-'a'];
            //cout<<t[i]<<" "<<ne<<endl;
            if(ne==-1) {
                cout<<"No"<<endl;
                ok=true;
                break;
            }
        }
        if(!ok)cout<<"Yes"<<endl;
    }
}
```
## 4月5日 树上DP/DFS
> https://ac.nowcoder.com/acm/problem/22598

n 个节点 n-1 条边的无向连通图，每条边有一个边权 wi；  
选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为 1 的点都不能到达 S。   
定义删除一条边的代价为这条边的边权,求最小代价。  
看到**n个点n-1条边实际上就是一颗树**；  
在以S为根的树上删掉权值和尽量小的一些边使得根和每一个叶子节点都不连通。

【树是最能体现递归的，递归是从顶向下的，转化成从底向上就变成了DP，所以“树上”的题目真是前变万化~~~既可以叫dp也可以叫dfs】

不管是写dp还是写搜索其实都是要分析原问题和子问题分别是什么的，我们的原问题是以S为根的子树删掉权值和尽量小的一些边使得S和每一个叶子节点都不连通，那么子问题也很简单，就是求以x为根的子树删掉一些边使得S和x的子树上每个叶子节点都不连通。要想在考虑x这个点的子树的时候就实现子树上每个叶子都和S不连通，那么有两种情况：把x和他的儿子断开，或者是，在x的子树上去把所有叶子节点都断开。如果我们用f[x]表示x的子树上的所有叶子和根断开的最小代价的话， $f[x]=\sum min(f[y],w[x][y])$
(y是x的儿子(枚举所有儿子,$w[x][y]$是x到y的边长)。 dfs在返回的时候维护这些值就好。  
即：**子问题**：以x为根的子树上的所有叶子和根断开的最小代价   
dfs转移时候**选择**断开与儿子的边还是断开儿子字树的边即可

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 100000 * 2 +10 ;
ll f[maxn/2];// f[x]表示x的子树上的所有叶子和根断开的最小代价
int p[maxn],h[maxn],ne[maxn],edge[maxn];
int num=0;

void addEdge(int from, int to,int w){ 
    p[++num] = to;//to->from
    ne[num] = h[from];
    h[from] = num;
    edge[num]=w;
    p[++num] = from;
    ne[num] = h[to];
    h[to]=num;
    edge[num]=w;
}
int inD[maxn/2];//入度
int n,m,s;
void dfs(int u,int fa)
{
    if(inD[u] == 1 && u != s){
        f[u] = 0x3f3f3f3f;
        return;
    }
    for(int i = h[u];i;i = ne[i])if(p[i]!=fa)
    {
        int child = p[i],w = edge[i];
        dfs(child,u);
        f[u] += min(1ll*w,f[child]);
    }
}
int main()
{
   // freopen("1.in","r",stdin);
    scanf("%d %d %d",&n,&m,&s);
    for(int i = 1 ;i <= m;i++)
    {
        int u,v,w;
        scanf("%d %d %d",&u,&v,&w);
        addEdge(u,v,w);
        ++inD[u],++inD[v];
    }
    dfs(s,0);
    cout<<f[s];
    return 0;
}
```
## 再来一个树上距离
> https://ac.nowcoder.com/acm/contest/5086/C
> 
求出B 到 C，C到 1的距离和 dis1   
求出A 到 1的距离 dis2  
如果 $dis1<dis2$ 肯定抓不到  
如果 $dis1>dis2$ 肯定抓的到  
如果 $dis1==dis2$时且$LCA(A,C) == 1$ 则他们俩最终会在1相遇,则抓不到，其他情况老师可以去$LCA(A,C)$守株待兔  


## 坑死我了的longlong
就因为一个错误调了一个小时没找出来。。。。。fuck fuck  
https://ac.nowcoder.com/acm/contest/5086/A  
一个数移到左边所减少的量=$nums[i]*k$ 增加的量为$sum(i-k,i)$  
总的减少量$nums[i]*k-sum(i-k,i)$
维护前缀和，枚举下标从k~n-1,找出最少的减少量delta即可
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int n;scanf("%d",&n);
        int k;scanf("%d",&k);
        int nums[maxn];
        ll sum[maxn]={0};
         //错误写法：int sum[maxn]
        unsigned ll ans=0;
        for(int i=1;i<=n;++i){
            scanf("%d",&nums[i-1]);
            ans+=i*nums[i-1];
            sum[i]=sum[i-1]+nums[i-1];
        }
        ll delta = 9223372036854775807;
        //错误写法：ll delta=0x3f3f3f3f
        for(int i=n-1;i>=k;--i){
            ll dd = nums[i]*k-sum[i]+sum[i-k];
            delta=min(delta,dd);
        }
        printf("%lld\n",ans-delta);
    }
}
```

## dfs预处理
定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。
比如说，47、744、4都是幸运数字而5、17、467都不是。
定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + ... + next(r - 1) + next(r)。  
dfs打表预处理出只含有4、7的数字  
然后O(n)顺着往下找即可，比如l=48 找到第一个大于l的数为74 则[48,74]这个区间的数的下一个幸运数都为74。 参看代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5+5;
ll a[N], k = 0;
void dfs(ll n)  //打表
{
    if(n>2e10) return;
    a[k++] = n;
    dfs(n*10+4);
    dfs(n*10+7);
}
 
int main()
{
    dfs(0);
    sort(a,a+k);
    ll l,r;
    scanf("%lld %lld",&l,&r);
    ll sum = 0, i = l, dx = 0;
    while(i<=r)
    {
        while(a[dx]<i) dx++;
        sum += a[dx]*(min(r,a[dx])-i+1);  //在i->第一个大于等于x的数这个区间内，每次加的都是这个第一个>=x的a[dx]
        i = a[dx]+1;  //下一次从a[dx]之后开始
    }
    printf("%lld\n",sum);
    return 0;
}
```
## 转换思维+树上dfs 4月8日
> https://ac.nowcoder.com/acm/problem/13886

是我最喜欢的树上dfs~~~
给你一棵 n 个节点的树（保证 n是偶数），你需要将 n个节点分为 n/2 个点对，使得所有点对的两个点的距离的和最小。

关键点：**思维转换:选点两两配对求距离和--》转换成选边**
- 在最短的距离和之中一条边一定不会被覆盖两次,也就是说对于一条边来说，其实只有选和不选两种可能。
- 对于一个点x，它子树中的点一定会尽量在子树中找到匹配的点内部消化掉（要么连父亲要么连兄弟），只有根是有可能会往上找一个点来匹配（不然又会出现重复覆盖一条边的情况）。  
这道题最关键的是转换思维，如果考虑两两配对并不容易编码，而是直接考虑边，边只有选和不选两种可能； 
对于当前点 x，如果它的子树（包括它自己）有偶数个点，那么肯定在子树里面就互相连完了，它不需要向上连；如果是奇数个点，x 就需要去匹配上面的点了，所以 x向它父亲连的边就要选。  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MAXN 20010
ll p[MAXN],h[MAXN],ne[MAXN],edgew[MAXN]; ll num=0;
void addEdge(int from, int to,int w)
{
    p[++num] = to;
    ne[num] = h[from];
    h[from] = num;
    edgew[num] = w;
    p[++num] = from;
    ne[num] = h[to];
    h[to] = num;
    edgew[num] = w;
}
ll ans=0;
ll cnt[MAXN>>1];//记录子树的节点数量
void dfs(int u,int father,int faw){
    cnt[u]=1;
    for(int i=h[u];i;i=ne[i])if(p[i]!=father)
    {
        dfs(p[i],u,edgew[i]);
        cnt[u]+=cnt[p[i]];
    }
    if(cnt[u]&1) ans+=faw;//加上和父亲的边
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        ans = 0;
        num=0;
        int n;cin>>n;
        memset(h, 0, sizeof(h));
        memset(cnt, 0, sizeof(cnt));
        for(int i = 1; i <= n-1; i++)
        {
            int x,y,w;
            scanf("%d%d%d", &x, &y, &w);
            addEdge(x, y, w);
        }
        dfs(1, 0, 0);
        printf("%lld\n", ans);
    }
}
```
## 树形DP+贪心
> https://ac.nowcoder.com/discuss/401669?type=101&order=0&pos=5&page=2
> https://ac.nowcoder.com/acm/problem/13249
一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。
你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。

首先肯定是从叶子节点开始选点变黑，感觉做过这类题，类似跳跃游戏什么的==；  
当选完一个点，选下一个点的策略是：选择这个点**第一个覆盖不到的**和**覆盖到的点**中能跳到最远距离的那个点即可。  
![图片说明](https://uploadfiles.nowcoder.com/images/20200409/7875723_1586445918222_1C272433ECCAE44CB57EDE264551B3B6 "图片标题")   
当我们按照能覆盖上就不选的方法从下往上选的时候，发现了3没有被下方的点覆盖，我们要做的事情其实是找个点（可能是自己可能是下方的点）覆盖了它，而不仅仅是选择它，在这个例子中显然选择5比选择3更好——这两种选择都能满足覆盖3，但是选择5能到覆盖更上方的点。也就说说，我们真正的策略应该是，当一个点没有被下方已经选了的点覆盖到的时候，我们选择一个它或者它下方的能向上覆盖的最远的点。另外，其实我们也并不关心这个点选的哪个，只需要知道往上能覆盖多远就行了，这个值其实可以直接维护到k数组里面，即我认为由于图中5号点的存在，在dfs返回上方的过程中，我们就可以认为k[4]值是9，k[3]是8（选5来替代选3/4）……  
///自己写的思路
dfs遍历中，从叶子节点往上维护一个left[]表示节点x可以再往上覆盖多远，left[u]=max(left[child]-1)；当left[i]为0时表示覆盖不到了，那么选择这个点，left就变成了k[i];    
因为我们要选择能覆盖到最远距离的点，dfs从下往上用k[i]去维护某个点能跳到的最远距离值就可以了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define MYINTMAX 0x3f3f3f3f
#define N 100005
ll k[N];//每个点能跳到最远的位置
ll ans, lef[N];//还剩的覆盖距离
ll n,tot,rt,dis[N],fa[N],h[N],ne[N<<1],p[N<<1],wi[N<<1];
void addEdge(int u,int v,int w){p[++tot]=v;ne[tot]=h[u];h[u]=tot;wi[tot]=w;}
void add(int u,int v){p[++tot]=v;ne[tot]=h[u];h[u]=tot;}
void dfs(int u,int father)
{
    int tmp;
    lef[u]=0;
    for(int i=h[u];i;i=ne[i])if(p[i]!=father)
    {
        dfs(p[i],u);
        lef[u]=max(lef[u],lef[p[i]]-1);
        k[u]=max(k[u],k[p[i]]-1);
    }
    if(lef[u]==0){//已经覆盖不到了
        ans++;
        lef[u]=k[u];
    }
}
int main()
{
    scanf("%d", &n);
    for (int i = 2; i <= n; i++)
    {
        int x;
        scanf("%d", &x);
        add(x,i);
    }
    for (int i = 1; i <= n; ++i)
        scanf("%d", &k[i]);
    dfs(1, 0);
    cout << ans << endl;
    return 0;
}
```
